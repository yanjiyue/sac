# 資料結構與演算法——楊子越
## :star: 作業
|hw1：[quick sort](https://github.com/yanjiyue/sac/blob/master/HW1/quicksort.ipynb)作業及[推導圖](https://github.com/yanjiyue/sac/blob/master/%E4%BD%9C%E6%A5%AD/quicksort.png)|
|---|
|[hw2](https://github.com/yanjiyue/sac/tree/master/HW2)|
|[HW3](https://github.com/yanjiyue/sac/tree/master/HW3)|
|[HW4](https://github.com/yanjiyue/sac/tree/master/HW4)|
|[HW5](https://github.com/yanjiyue/sac/tree/master/HW5)|

---
## :star: 練習
* [design linklist](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/design%20linked%20list.py)
* [min stack](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/min%20stack.py)
* [implement queue using stacks](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/Implement%20Queue%20using%20Stacks.py)
* [set mismatch](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/set%20mismatch%E8%A7%A3%E9%87%8B)
* [Two Sum](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/two%20sum.py)
* [Univalued Binary Tree](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/Univalued%20Binary%20Tree.py)
* [reverse integer](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/reverse%20integer.py)
* [roman to integer](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/roman%20to%20integer.py)
* [palindrome number](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/palindrome%20number.py)
* [remove element](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/remove%20element.py)
* [design hashmap](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/design%20hashmap.py)
* [count and say](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/count%20and%20say.py)
* [longest common prefix](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/longest%20common%20prefix.py)
* [plus one](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/plus%20one.py)
* [sqrt(x)](https://github.com/yanjiyue/sac/blob/master/%E7%B7%B4%E7%BF%92/sqrt(x).py)
---
---
## :book: 課程資料
* [linked list](https://docs.google.com/presentation/d/e/2PACX-1vTB218-EdUZ5jpNz6Uv4TOZQc37Y281v128_aRcWC6EhkTQs5bS8fh7yysmcuzb9R2QPN6_PDshFWL_/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [stack&queue](https://docs.google.com/presentation/d/e/2PACX-1vQ1hb79im0vqpApCttGnXAFRT8SqH9HQP0b_oyVRCV8SVyiHLkHJjidYGAfxkvq468QMumFIDdTeiB-/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [set](https://docs.google.com/presentation/d/e/2PACX-1vT6BvB7aI9oLgyum8tdIgGVr8kabqtwo8KZV3ayzKKQqGkpAnvrjT3JabWu-Hms9kUaDILyCU8-Qqhl/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [insertion sort](https://docs.google.com/presentation/d/e/2PACX-1vQOTMDM-5-OUaGfnLUOFVgefFwSVRplSwnbicp0CXOQrB5H8RM_1Aq8o_4JxHlncEmhjvqk3tzcoB7s/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [quick sort](https://docs.google.com/presentation/d/e/2PACX-1vSqz8sTxT4xyjgiz-htLvZd7FZ_5ZzgKf60pFEoNLU5S77JxrsGJ2vd15CdxlfLtT3g2aizHP-Ebk9b/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [heap sort](https://docs.google.com/presentation/d/e/2PACX-1vRAGwnUvg6BcXoML5u9f4gO6YKcz0vXf7bDnPho_S7mG5D0SBR78djt91RKUPMxqNfkVIcu3l5WCXPh/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [merge sort](https://docs.google.com/presentation/d/e/2PACX-1vToxkEzc1H1RT5MI9G941KQFBC7GO_Efn95wTqXLEdr3LDBSNcQb-M46IOC-_RzZih6IBEwwy3rWQuE/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [binary tree](https://docs.google.com/presentation/d/e/2PACX-1vSC3P8sGElP48mJTjqT309470SmTFBwJXWsU9hTX2hg5tVpiG4yC703qA7ibPep-Qakmm2Mw_F-ScZh/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [binary search tree](https://docs.google.com/presentation/d/e/2PACX-1vQgUh73yvSdxAvMH50DHWJ5lsCX8-daMxtoltU9rYW7xCmqYz2A1wOv0Vcx_F9KO5ZUvZBv3IF1TjGi/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [red black tree](https://docs.google.com/presentation/d/e/2PACX-1vRxyJRARq0BNuGJq_o2cUHIXBWrRSZrAOyXOSt9qCTSjQtyp8XqFq3VuNn3gCt3sXenOZmWLqIjcyFs/pub?start=false&loop=false&delayms=3000&slide=id.g5fc27284d4_0_908)
* [hash table](https://docs.google.com/presentation/d/e/2PACX-1vT1HO9Nl475k2bR0l1x8_Tr4V5Wzx0BEqp9bpmHckvj8kTeJehhYVlOJUDVPhLQm6kjGCJ_sLMSBUw5/pub?start=false&loop=false&delayms=3000&slide=id.g790b8351ca_0_114)
* [breadth-first search](https://docs.google.com/presentation/d/e/2PACX-1vSYJYXUXvGAeTZ5fknxj_-EPm3zxgy4ITdImrXzy63Y-iZgs8uwVNmOaZlnx9fUNzsbo8kphvMTa0c4/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [depth-first search](https://docs.google.com/presentation/d/e/2PACX-1vTma_vOZyE70O23KWw4I4Y78aAaT5fJSTq7Mae912kCwka_u5ZMWPoo14D86-x-57kZPbb6hAGktSW4/pub?start=false&loop=false&delayms=3000&slide=id.p)
* [minimum spanning tree](https://docs.google.com/presentation/d/e/2PACX-1vTorNDEyhYA4ZAt5jEqOmFs2cQiUAYvkTp-R0DOn9B3c1MuUecV-a1wNakFIrJxA6AoUFGzbl3OQBIJ/pub?start=false&loop=false&delayms=3000&slide=id.g5fc27284d4_0_908)
* [shortest path](https://docs.google.com/presentation/d/e/2PACX-1vTgHO5AkHJS6iN6bnnBMMdHv6E4rabnrC0KwyTRfjad8Ab3IQjbnGvZuQOjDC9t7nKqeroiwcuasJrI/pub?start=false&loop=false&delayms=3000&slide=id.g7b9afdb0e7_0_0)
---
---
## :bookmark: 筆記 


| sorting algorithm | average time | best time | worst time | extra space (in-place) | stability |
| ----------------- | ------------ | --------- | ---------- | ---------------------- | --------- |
| quick sort        | O(nlogn)     | O(nlogn)  | O(n^2)     | O(n)                   | unstable  |
| merge sort        | O(nlogn)     | O(nlogn)  | O(nlogn)   | O(n)                   | stable    |
| heap sort         | O(nlogn)     | O(nlogn)  | O(nlogn)   | O(1) | unstable  |



| tree type          |        | average | worst |
| ------------------ | ------ | ------- | ----- |
| binary search tree | space  | O(n)    | O(n)  |
| binary search tree | insert | O(logn) | O(n)  |
| binary search tree | search | O(logn) | O(n)  |
| binary search tree | delete | O(logn) | O(n)  |
| red black tree | space  | O(n)    | O(n)  |
| red black tree | insert | O(logn) | O(logn)  |
| red black tree | search | O(logn) | O(logn)  |
| red black tree | delete | O(logn) | O(logn)  |

### :link: [linked list](https://blog.csdn.net/weixin_42139757/article/details/82108515)
>prev指向前面節點|item數據|指向後面的節點
#### LinkedList 特點
 - 雙向鏈表實現
 - 元素時有序的，輸出順序與輸入順序一致
 - 允許元素為 null
 - 要找到某個結點，必須從頭開始遍曆。（查詢慢，增刪快）
 - 和 ArrayList 一樣，不是同步容器
---
 
### :runner: [quick sort](https://baike.baidu.com/item/快速排序算法/369842?fromtitle=quick%20sort&fromid=18082058&fr=aladdin)
>快速排序（Quicksort）是對冒泡排序的一種改進。它的基本思想是：通過一趟排序將要排序的數據分割成獨立的兩部分，其中一部分的所有數據都比另外一部分的所有數據都要小，然後再按此方法對這兩部分數據分別進行快速排序，整個排序過程可以遞歸進行，以此達到整個數據變成有序序列。
#### 排序流程
快速排序演算法通過多次比較和交換來實現排序，其排序流程如下： 
- 首先設定一個分界值，通過該分界值將數組分成左右兩部分。 
- 將大於或等於分界值的數據集中到數組右邊，小於分界值的數據集中到數組的左邊。此時，左邊部分中各元素都小於或等於分界值，而右邊部分中各元素都大於或等於分界值。 
- 然後，左邊和右邊的數據可以獨立排序。對於左側的數組數據，又可以取一個分界值，將該部分數據分成左右兩部分，同樣在左邊放置較小值，右邊放置較大值。右側的數組數據也可以做類似處理。 
- 重複上述過程，可以看出，這是一個遞歸定義。通過遞歸將左側部分排好序後，再遞歸排好右側部分的順序。當左、右兩個部分各數據排序完成後，整個數組的排序也就完成了。
#### 原理
設要排序的數組是A[0]……A[N-1]，首先任意選取一個數據（通常選用數組的第一個數）作為關鍵數據，然後將所有比它小的數都放到它左邊，所有比它大的數都放到它右邊，這個過程稱為一趟快速排序。值得注意的是，快速排序不是一種穩定的排序演算法，也就是說，多個相同的值的相對位置也許會在演算法結束時產生變動。
#### 一趟快速排序的演算法是：
- 設置兩個變數i、j，排序開始的時候：i=0，j=N-1； 
- 以第一個數組元素作為關鍵數據，賦值給key，即key=A[0]； 
- 從j開始向前搜索，即由後開始向前搜索(j--)，找到第一個小於key的值A[j]，將A[j]和A[i]的值交換； 
- 從i開始向後搜索，即由前開始向後搜索(i++)，找到第一個大於key的A[i]，將A[i]和A[j]的值交換；
- 重複第3、4步，直到i=j； (3,4步中，沒找到符合條件的值，即3中A[j]不小於key,4中A[i]不大於key的時候改變j、i的值，使得j=j-1，i=i+1，直至找到為止。找到符合條件的值，進行交換的時候i， j指針位置不變。另外，i==j這一過程一定正好是i+或j-完成的時候，此時令迴圈結束）。
---
 
### :hamburger: [heap sort](https://baike.baidu.com/item/堆排序/2840151?fr=aladdin)
>堆排序（英語：Heapsort）是指利用堆這種數據結構所設計的一種排序演算法。堆是一個近似完全二叉樹的結構，並同時滿足堆積的性質：即子結點的鍵值或索引總是小於（或者大於）它的父節點。
#### 堆的操作
在堆的數據結構中，堆中的最大值總是位於根節點（在優先佇列中使用堆的話堆中的最小值位於根節點）。堆中定義以下幾種操作：

- 最大堆調整（Max Heapify）：將堆的末端子節點作調整，使得子節點永遠小於父節點
- 創建最大堆（Build Max Heap）：將堆中的所有數據重新排序
- 堆排序（HeapSort）：移除位在第一個數據的根節點，並做最大堆調整的遞歸運算
---
 
### :melon: [merge sort](https://baike.baidu.com/item/归并排序/1639015?fr=aladdin)
>歸併排序（MERGE-SORT）是建立在歸併操作上的一種有效的排序演算法,該演算法是採用分治法（Divide and Conquer）的一個非常典型的應用。將已有序的子序列合併，得到完全有序的序列；即先使每個子序列有序，再使子序列段間有序。若將兩個有序表合併成一個有序表，稱為二路歸併。歸併排序是一種穩定的排序方法。

#### 歸併操作 
 - 歸併操作(merge)，也叫歸併演算法，指的是將兩個順序序列合併成一個順序序列的方法。
 - 如設有數列{6，202，100，301，38，8，1}
 - 初始狀態：6,202,100,301,38,8,1
 - 第一次歸併後：{6,202},{100,301},{8,38},{1}，比較次數：3；
 - 第二次歸併後：{6,100,202,301}，{1,8,38}，比較次數：4；
 - 第三次歸併後：{1,6,8,38,100,202,301},比較次數：4；
 - 總的比較次數為：3+4+4=11；
 - 逆序數為14；
#### 演算法描述
 - 歸併操作的工作原理如下：
  - 第一步：申請空間，使其大小為兩個已經排序序列之和，該空間用來存放合併後的序列
  - 第二步：設定兩個指針，最初位置分別為兩個已經排序序列的起始位置
  - 第三步：比較兩個指針所指向的元素，選擇相對小的元素放入到合併空間，並移動指針到下一位置
  - 重複步驟3直到某一指針超出序列尾
  - 將另一序列剩下的所有元素直接複製到合併序列尾
#### 比較
 - 歸併排序是穩定的排序.即相等的元素的順序不會改變.如輸入記錄 1(1) 3(2) 2(3) 2(4) 5(5) (括弧中是記錄的關鍵字)時輸出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按輸入的順序.這對要排序數據包含多個資訊而要按其中的某一個資訊排序,要求其他資訊儘量按輸入的順序排列時很重要。歸併排序的比較次數小於快速排序的比較次數，移動次數一般多於快速排序的移動次數。
#### 複雜度
 - 歸併排序比較佔用記憶體，但卻是一種效率高且穩定的演算法。改進歸併排序在歸併時先判斷前段序列的最大值與後段序列最小值的關係再確定是否進行複製比較。如果前段序列的最大值小於等於後段序列最小值，則說明序列可以直接形成一段有序序列不需要再歸併，反之則需要。所以在序列本身有序的情況下時間複雜度可以降至O(n);TimSort可以說是歸併排序的終極優化版本，主要思想就是檢測序列中的天然有序子段（若檢測到嚴格降序子段則翻轉序列為昇冪子段）。在最好情況下無論昇冪還是降序都可以使時間複雜度降至為O(n)，具有很強的自適應性。
---
 
### :palm_tree: binary tree
* [binary tree1](http://www.csie.ntnu.edu.tw/~u91029/BinaryTree.html)
* [binary tree2](https://new.qq.com/rain/a/20190118A0V28C)
* [binary tree3](https://baike.baidu.com/item/二叉树/1602879?fr=aladdin)
---
### :pineapple: hash table
[點擊此處](https://github.com/yanjiyue/sac/blob/master/HW4/hash%20table%E6%B5%81%E7%A8%8B%E5%9C%96%E8%88%87%E5%AD%B8%E7%BF%92%E6%AD%B7%E7%A8%8B%E3%80%81%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8B.md)

---

### :train2:  bfs/dfs
[點擊此處](https://github.com/yanjiyue/sac/blob/master/HW5/%E6%B5%81%E7%A8%8B%E5%9C%96%E3%80%81%E5%AD%B8%E7%BF%92%E6%AD%B7%E7%A8%8B%E3%80%81%E5%8E%9F%E7%90%86%E8%88%87%E6%AF%94%E8%BC%83.md)

---
